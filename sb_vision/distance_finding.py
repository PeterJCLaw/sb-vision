"""
Handlers for detecting 3D marker Location.

Also handles loading the calibration file which is passed into the
location finding function.
"""

import functools
import re
from pathlib import Path
from typing import Any, Dict, List, Tuple

import cv2
import numpy as np
from lxml import etree


def _get_text(element: etree.Element) -> List[str]:
    """Parse an xml tag with space-separated variables."""
    text = []  # type: List[str]
    for e in element.itertext():
        if e.strip():
            text += re.split('\s+', re.sub('\n', '', e.strip()))
    return text


def get_calibration(file_name: Path) -> Dict[str, Any]:
    """
    Parse a calibration xml generated by the camera calibration tool.

    (see https://docs.opencv.org/3.4.0/d7/d21/tutorial_interactive_calibration.html)
    :param file_name: name of xml file to parse
    :return: calibrations from the file in a dictionary
    """
    calibrations = {}
    with file_name.open() as file:
        tree = etree.parse(file)
        root = tree.getroot()
        for element in root:
            if 'type_id' in element.attrib and element.attrib[
               'type_id'] == 'opencv-matrix':
                rows, cols = int(element.find('rows').text), int(
                    element.find('cols').text)
                data_type = element.find('dt').text
                values = _get_text(element.find('data'))
                if data_type == 'd':  # doubles
                    data = np.reshape([float(v) for v in values],
                                      (rows, cols)).tolist()
                else:
                    raise ValueError('Invalid data type in xml')
            # Integer tag names
            elif element.tag in ['framesCount', 'cameraResolution']:
                values = _get_text(element)
                data = [int(v) for v in values]
            elif element.tag in ['avg_reprojection_error']:
                values = _get_text(element)
                data = [float(v) for v in values]
            else:
                data = _get_text(element)
            calibrations[element.tag] = data
    return calibrations


@functools.lru_cache()
def load_camera_calibrations(file_name: Path) -> Tuple[List[List[float]],
                                                       List[List[float]]]:
    """
    Load camera calibrations from a file.

    :param file_name: file to load
    :return: camera calibrations
    """
    calibrations = get_calibration(file_name)
    camera_matrix = calibrations['cameraMatrix']
    distance_coefficents = calibrations['dist_coeffs']
    return camera_matrix, distance_coefficents


def calculate_transforms(
        marker_size: Tuple[float, float],
        pixel_coords: List[Tuple[float, float]],
        camera_matrix: List[List[float]],
        distance_coefficients: List[List[float]]):
    """
    Calculate the position of a marker.

    given the pixel co-ordinates of the corners and the calibrations
    of the camera.

    :param marker_size: size of the marker
    :param pixel_coords: pixel co-ordinates of the corners of the marker
        (clockwise around the marker)
    :param camera_matrix: calibration matrix for the camera
    :param distance_coefficients: distance calibration for the camera
    :return: translation and orientation of the marker
    """
    x, y = marker_size
    x /= 2
    y /= 2

    # create the rectangle representing the marker in 3D
    object_points = np.array([
        [x, y, 0],
        [x, -y, 0],
        [-x, -y, 0],
        [-x, y, 0],
    ])

    _, orientation_vector, translation_vector = cv2.solvePnP(
        object_points,
        pixel_coords,
        np.array([np.array(xi) for xi in camera_matrix]),
        np.array([np.array(xi) for xi in distance_coefficients]),
    )
    translation_vector = tuple(v[0] for v in translation_vector)
    orientation_vector = tuple(v[0] for v in orientation_vector)

    return translation_vector, orientation_vector
